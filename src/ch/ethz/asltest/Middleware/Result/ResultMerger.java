package ch.ethz.asltest.Middleware.Result;

import ch.ethz.asltest.Middleware.Global.Parameters;
import ch.ethz.asltest.Middleware.Log.Log;
import ch.ethz.asltest.Middleware.Log.Statistics;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.LinkedList;

/*
    The ResultMerger class is used to merge multiple responses from servers into one response that gets forwarded
    to clients. After adding all Results, merge() will conduct the merge logic and can be used write the appropriate
    response back to the client by using writeToClient. This method will automatically merge sharded multi-get responses
    into one valid response.
    If, for example, one of three queries of a sharded multi-get query responds with an error, the merger
    will write a valid error message to the client when using writeToClient.
 */

public class ResultMerger {

    private LinkedList<Result> resultList;

    private boolean merged;
    private int valueResultCount;
    private int storedResultCount;

    private boolean previousHasRemainingResultValid;
    private boolean previousHasRemainingResult;


    /*
     The array of bytebuffers, which are prepared properly to be written in sequence.
     By writing one after the other from the current position to their limits,
     the resulting stream will be a valid merged response.
     This buffer is generated by the merge() method and then written back to a client
     with writeToClient().
      */
    private ByteBuffer[] sourceByteBuffers;

    // The number of ByteBuffers contained in sourceByteBuffers
    private int sourceCount;

    public ResultMerger(){
        // The linked hash set preserves order
        resultList = new LinkedList<>();
        sourceByteBuffers = new ByteBuffer[Parameters.getInteger("assembler_max_responses_mergeable")];
    }

    public void addResult(Result result) throws AlreadyMergedException{
        if (merged){
            throw new AlreadyMergedException("[ResultMerger] Attempting operation on already merged result set");
        }
        resultList.add(result);
    }

    public void clear(){
        resultList.clear();
        merged = false;
        valueResultCount = 0;
        storedResultCount = 0;
        previousHasRemainingResultValid = false;

        sourceCount = 0;
        for (int i = 0; i < sourceByteBuffers.length; i++){
            sourceByteBuffers[i] = null;
        }
    }

    public void release() throws NotMergedException{
        if (!merged){
            throw new NotMergedException("[ResultMerger] Attempting operation on not yet merged result set");
        }
        for (Result result : resultList){
            result.getResponseAssembler().release();
        }
    }

    public class NotMergedException extends Exception{
        public NotMergedException(String message){
            super(message);
        }
    }

    public class AlreadyMergedException extends Exception{
        public AlreadyMergedException(String message){
            super(message);
        }
    }

    public void merge(){

        if (merged){
            return;
        }

        if (resultList.isEmpty()){
            Log.warn("[ResultMerger] Result set is empty");
            return;
        }

        for (Result currentResult : resultList){

            if (currentResult instanceof Result.ErrorResult) {
                sourceByteBuffers[0] = currentResult.byteBuffer;
                sourceCount = 1;
                break;
            } else if (currentResult instanceof Result.ServerErrorResult) {
                sourceByteBuffers[0] = currentResult.byteBuffer;
                sourceCount = 1;
                break;
            } else if (currentResult instanceof  Result.ClientErrorResult){
                sourceByteBuffers[0] = currentResult.byteBuffer;
                sourceCount = 1;
                break;
            } else if (currentResult instanceof  Result.ValueResult){
                valueResultCount++;
                if (sourceCount >= sourceByteBuffers.length){
                    Log.error("[ResultMerger] Cannot add result to merger, run out of space (increase assembler_max_responses_mergeable)");
                }
                sourceByteBuffers[sourceCount] = currentResult.byteBuffer;
                sourceCount++;
            } else if (currentResult instanceof Result.StoredResult){
                storedResultCount++;
                if (sourceCount >= sourceByteBuffers.length){
                    Log.error("[ResultMerger] Cannot add result to merger, run out of space (increase assembler_max_responses_mergeable)");
                }
                sourceByteBuffers[0] = currentResult.byteBuffer;
                sourceCount = 1;
            }
        }

        // Make sure we don't have a mix of STORED and VALUE responses
        if (!((valueResultCount == 0 && storedResultCount == resultList.size()) || (valueResultCount == resultList.size() && storedResultCount == 0))){
            Log.error("[ResultMerger] Received results of both value and stored, or another unknown type has occured");
            return;
        }

        if (valueResultCount > 0){
            Result lastResult = resultList.getLast();
            ((Result.ValueResult) lastResult).setLimitToEnd();
        }

        merged = true;
    }


    /*
     Check how many bytes are remaining in the consolidated response.
     */
    public boolean hasRemaining() throws  NotMergedException{
        if (!merged){
            throw new NotMergedException("[ResultMerger] Attempting operation on not yet merged result set");
        }

        if (previousHasRemainingResultValid){
            return previousHasRemainingResult;
        }

        for(ByteBuffer currentByteBuffer : sourceByteBuffers){
            // May be zero, since we iterate over an array
            if (currentByteBuffer == null)
                continue;

            if (currentByteBuffer.hasRemaining()){
                previousHasRemainingResult = true;
                previousHasRemainingResultValid = true;
                return true;
            }
        }
        previousHasRemainingResult = false;
        previousHasRemainingResultValid = true;
        return false;
    }

    /*
     Writes the generated, consolidated response to the given socket channel.
     Returns how many bytes have been written.
      */

    public long writeToClient(SocketChannel socketChannel) throws NotMergedException{
        if (!merged){
            throw new NotMergedException("[ResultMerger] Attempting operation on not yet merged result set");
        }

        try{
            long bytesWritten = socketChannel.write(sourceByteBuffers, 0, sourceCount);
            if (bytesWritten != 0){
                previousHasRemainingResultValid = false;
            }
            return bytesWritten;
        } catch (IOException iOException){
            Log.error("[ResultMerger] IOError on writing merged result back to client: " + iOException.getMessage());
        }
        return 0;
    }


}
